##function that will be used by boot
boot.coef<- function(data,indices){
 y <- fit + e.c[indices]
 mod <- gls(y ~ X,cor=corAR1(form=~yr|name),meth="ML")
 coef(mod)
}

boot.pred<- function(data,indices){
 y <- fit + e.c[indices]
 mod <- gls(y ~ X,cor=corAR1(form=~yr|name),meth="ML")
 predict(mod)
}

boot.coef.lme<- function(data,indices){
 y <- fit + e.c[indices]
 mod <- lme(y ~ X,random=~1|name,cor=corAR1(form=~yr|name),meth="ML")
 coef(mod)
}

boot.pred.lme<- function(data,indices){
 y <- fit + e.c[indices]
 mod <- lme(y ~ X,random=~1|name,cor=corAR1(form=~yr|name),meth="ML")
 predict(mod,lev=0)
}

##case bootstrapping, where x and y are shuffled as cases
boot.coef.case<-function(data, indices){
 data <- data[indices,] # select obs. in bootstrap sample
 mod <- gls(y ~ x, data=data, cor=corAR1(form=~yr|name),meth="ML")
 coef(mod) # return predicted values
}

boot.pred.case<-function(data, indices){
 data <- data[indices,] # select obs. in bootstrap sample
 mod <- gls(y ~ x, data=data, cor=corAR1(form=~yr|name),meth="ML")
 predict(mod) # return predicted values
}

##function for extacting 3 types of confidence intervals
CI<-function(boot.obj){
 types<-c("norm","basic","perc")
 conf<-array(NA,dim=c(220,3,2))##220 = n, 3=# of cis, 2 =1 high+1 low
 for(i in 1:dim(conf)[1]){
  for(j in 1:dim(conf)[2]){
   if(j == 1){
    ci<-boot.ci(boot.obj,index=i,type="norm")
    conf[i,j,]<-ci$norm[-1]
   }   
   if(j == 2){
    ci<-boot.ci(boot.obj,index=i,type="basic")
    conf[i,j,]<-ci$basic[-(1:3)]
   }
   if(j == 3){
    ci<-boot.ci(boot.obj,index=i,type="perc")
    conf[i,j,]<-ci$perc[-(1:3)]
 }}}
conf}

##function for plotting confi bands
confi.band<-function(x,ci.obj,which=NA,col='red',lwd=2,lty=2,leg=TRUE){ 
 ##x is the X-variable
 ##ci.obj is the array generated by the function CI
 ##which is type of confidence interval, defaults to all three types
 ##that are calculated by CI
 ##col is color, default is red
 ##lwd is width of line, default wd is 2
 ##lty is the line type, default to lty 2 which is dashed
 ##leg is a logical if a legend should be ploted, defaults to TRUE
 types<-c("norm","basic","perc")
 if(is.na(which)){
  for(i in 1:dim(ci.obj)[2]){
   points(sort(x),ci.obj[,i,1][order(x)],type='l',lwd=lwd,col=1+i,lty=lty)
   points(sort(x),ci.obj[,i,2][order(x)],type='l',lwd=lwd,col=1+i,lty=lty)
  }
 if(leg)
 legend("bottomright",legend=types,col=1+1:dim(ci.obj)[2],lwd=lwd,lty=lty,bty='n')
 }
 else{
  i<-c(1:3)[types==which]
  points(sort(x),ci.obj[,i,1][order(x)],type='l',lwd=lwd,col=col,lty=lty)
  points(sort(x),ci.obj[,i,2][order(x)],type='l',lwd=lwd,col=col,lty=lty)
  if(leg)
  legend("bottomright",legend=which,col=col,lwd=lwd,lty=lty,bty='n')
}}



##for permutation test, call to boot (sim="permutation" does not work here)
##this algo is for simple gls with AR1 sturc
##not for multiple regression or other models as written
perm.coef<- function(x, y, R, data=NA, strata=NA,torus=FALSE){
 ##strata is a group variable to shuffle within
 ##torus, if TRUE then shuffling keeps asending order of strata in dataframe during shuffles
 holder<-rep(NA,R)
 if(is.data.frame(data)){
  x <- data$x
  y <- data$y
  strata <- data$strata
 }
 if(is.na(strata[1])){
  for(i in 1:R){
   x.shuffle <- x[sample(220)]
   mod <- gls(y ~ x.shuffle,cor=corAR1(form=~yr|name))
   holder[i]<-coef(mod)[2]
   print(i)
 }}
 else{
  uni.strata<-unique(strata)##order that they come in the vector
  n.strata<-length(uni.strata)
  x.shuffle <- x
  rows<-1:220
  if(torus==TRUE){
   for(i in 1:R){
    for(j in 1:n.strata){
     ##assuming rows of data are orderd chronologically
     plane <- rep(rows[strata==uni.strata[j]],2)##these are the row ids
     pstart <- sample(11)[1] ##selects random start from 1 to 11
     x.shuffle[rows[strata==uni.strata[j]]] <- x[plane[pstart:(pstart+10)]] ##10 b/c there are 11 yrs
    } 
    mod <- gls(y ~ x.shuffle,cor=corAR1(form=~yr|name))
    holder[i]<-coef(mod)[2]
    print(i)
  }}
  else{
   for(i in 1:R){
    for(j in 1:n.strata){
     x.shuffle[rows[strata==uni.strata[j]]] <- sample(x[strata==uni.strata[j]]) 
    } 
    mod <- gls(y ~ x.shuffle,cor=corAR1(form=~yr|name))
    holder[i]<-coef(mod)[2]
    print(i)
 }}}
holder
}

